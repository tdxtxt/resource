数据结构笔记

一、数组（线性）


二、链表（线性）


三、树（非线性）
   二叉树：每个节点包括所含数据，同时存在左右两个节点的引用
   满二叉树:第n层节点个数为2^(n-1)
   完全二叉树：从左到右每一层挨个节点存放数据
   平衡二叉树：最大深度与最小深度之间的差距不能超过1
   根节点：没有父节点的节点
   叶子节点：没有左右子树的节点
   非叶子节点：有左子树或者右子树的节点  

四、数据结构
   4.1、队列【队尾添加元素，队首拿出元素，遵循先进先出的原则】
		入队操作enqueue：
		出队操作dequeue：
		查看队首元素getFront：
   
	4.1.1、优先队列
		底层实现使用最大堆MaxHeap
		入队: 直接向MaxHeap添加元素
		出队：获取MaxHeap堆顶元素
		时间复杂度:
		经典问题：在100000个元素中选出前100名？（解答：使用一个优先队列，队首优先级放低的元素，首先遍历100000个元素依次入队到队列中，当超过100个的时候，先和队首元素比较，若优先级更高，则先出队，在入队该元素）
		java标准库：PriorityQueue，它内部是一个最小堆实现，但是提供一个Comparator比较器，自己定义比较规则
		
   
   4.2、栈【先进先出的顺序】
        入栈push：
		出栈pop：
		查看栈顶元素peek：
   
   
   4.4、堆【类似金字塔，塔顶是极端元素(最大或者最小)，每一个节点比子节点元素都要大或者小】
		4.4.1、二叉堆
	    堆顶：根节点元素
		堆底：最后一层二叉树中最右边一个元素
        使用数组实现技巧：设当前节点为第n个索引，求左右子节点和父节点分别为第几个索引？左节点索引=2*n   右节点索引=2*n+1    父节点索引=n/2
		
		添加元素（SiftUp上浮操作）：先放入到堆底，然后和父节点比较，若比其大，则交换位置，循环上浮直到结束
        取出元素（SiftDown下浮操作）: 取出对顶元素，同时将堆底元素放入到堆顶，再把堆顶元素依次和左右子元素中最大元素互换位置，循环下浮直到结束
		replace:取出最大元素后，放入一个新元素  实现：可以直接将堆顶元素替换以后SiftDown。
		heapify:将任意数组整理为堆的形状  实现:找到最后一个非叶子节点，执行SiftDown操作，然后找到倒数第二个非叶子节点，执行SiftDown操作，循环以上操作步骤直到根节点
		
   4.3、二分搜索树【任一节值大于左节点值并且小于右节点的值，并且为二叉树】
        添加元素（add）：从根节点进行对比，1、若比根节点小，再和左子树根节点进行比较，直到可插入到其子节点中；2若比根节点大，再和右子树根节点进行比较，直到可插入到其子节点中
		遍历元素：分前序遍历；中序遍历；后序遍历
		移除元素：1、只有左子树节点；2、只有右子树节点；3、叶子节点；4、都有左右子树节点，此时找该节点的后继(右子树种最小的节点)替换该删除节点。
   
   4.4、线段树(区间树)【它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点这些节点存储区间相应的信息(这些信息代表这段区间某一个操作结果集)】
		复杂度O(logn)
		功能：使用线段树可以快速的查找某一个节点在若干条线段中出现的次数
   4.5、集合（Set类）
   
   
   4.6、映射（Map类）
       4.5.1、java标准库TreeMap：可以理解底层为红黑树
   
   
   4.7、List类